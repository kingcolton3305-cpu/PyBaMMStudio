# pybamm_studio_app.py
from __future__ import annotations
import io, json, sys, datetime as dt
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import streamlit as st

try:
    import pybamm as pb
    _PYBAMM_OK = True
    _PYBAMM_VER = pb.__version__
except Exception:
    _PYBAMM_OK = False
    _PYBAMM_VER = "unavailable"

# ---------- Data classes ----------
@dataclass
class Step:
    kind: str                  # "Charge" | "Discharge" | "Rest" | "Hold"
    rate: Optional[str] = None # e.g. "0.5C" or "-1C"
    until_voltage_V: Optional[float] = None
    until_current_C: Optional[str] = None
    rest_min: Optional[float] = None

# ---------- Helpers ----------
def _coerce(s: str) -> Any:
    s = s.strip()
    if s.lower() in ("true","false"):
        return s.lower()=="true"
    try:
        return float(s)
    except ValueError:
        return s

def parse_kv_block(block: str) -> Dict[str, Any]:
    """Robust KV parser. Lines without ':' are ignored."""
    out: Dict[str, Any] = {}
    for raw in block.splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        k, sep, v = line.partition(":")
        if not sep:
            # not a key:value line → skip to avoid ValueError
            continue
        out[k.strip()] = _coerce(v)
    return out

def parse_steps(lines: List[str]) -> List[Step]:
    """Accept human lines like:
       Charge at 0.5C until 4.2V
       Discharge at 1C until 3.0V
       Rest for 5 min
       Hold at 4.2V until C/50
    """
    steps: List[Step] = []
    for raw in lines:
        s = raw.strip()
        if not s:
            continue
        low = s.lower()
        if low.startswith("rest"):
            # Rest for X min
            tmin = 5.0
            tokens = low.split()
            for i, tok in enumerate(tokens):
                if tok.replace(".","",1).isdigit():
                    tmin = float(tok)
                    break
            steps.append(Step(kind="Rest", rest_min=tmin))
            continue
        if low.startswith("hold"):
            # Hold at 4.2V until C/50
            until_I = None
            if "until" in low:
                until_I = s.split("until",1)[1].strip()
            steps.append(Step(kind="Hold", until_current_C=until_I))
            continue
        # Charge/Discharge with rate and voltage cutoff
        if low.startswith("charge"):
            kind = "Charge"
        elif low.startswith("discharge"):
            kind = "Discharge"
        else:
            # Unknown line, ignore rather than crashing
            continue
        # rate
        rate = None
        if " at " in low:
            rate = s.split(" at ",1)[1]
            # trim trailing " until ..." if present
            if " until " in rate.lower():
                rate = rate.split(" until ",1)[0].strip()
        # voltage cutoff
        vcut = None
        if "until" in low and "v" in low:
            tail = low.split("until",1)[1]
            # find first number in original string slice
            tail_orig = s.lower().split("until",1)[1]
            for tok in tail_orig.replace("v"," ").split():
                try:
                    vcut = float(tok)
                    break
                except ValueError:
                    pass
        steps.append(Step(kind=kind, rate=rate, until_voltage_V=vcut))
    return steps

def to_pybamm_experiment(steps: List[Step], temperature_C: float) -> Tuple[pb.Experiment, List[str]]:
    lines: List[str] = []
    for s in steps:
        if s.kind in ("Charge","Discharge"):
            if s.until_voltage_V is not None:
                lines.append(f"{s.kind} at {s.rate} until {s.until_voltage_V}V")
            elif s.until_current_C is not None:
                lines.append(f"{s.kind} at {s.rate} until {s.until_current_C}")
            else:
                lines.append(f"{s.kind} at {s.rate} for 10 minutes")
        elif s.kind=="Rest":
            lines.append(f"Rest for {s.rest_min or 5} minutes")
        elif s.kind=="Hold":
            lines.append(f"Hold at 4.2V until {s.until_current_C or 'C/50'}")
    exp = pb.Experiment(lines, temperature=temperature_C+273.15)
    return exp, lines

def emit_script(lines: List[str], overlay: Dict[str, Any], tempC: float) -> str:
    lines_json = json.dumps(lines, indent=2)
    overlay_json = json.dumps(overlay, indent=2)
    return f"""# Auto-generated by PyBaMM Studio
import pybamm as pb

_LINES = {lines_json}
_OVERLAY = {overlay_json}
_TEMPC = {tempC}

def build_model():
    return pb.lithium_ion.SPM()

def get_parameter_values():
    p = pb.ParameterValues("Chen2020")
    if _OVERLAY:
        p.update(_OVERLAY)
    return p

def solve(model, params, experiment=None):
    exp = experiment or pb.Experiment(_LINES, temperature=_TEMPC+273.15)
    sim = pb.Simulation(model, parameter_values=params, experiment=exp)
    sol = sim.solve()
    return sim, sol
"""

# ---------- UI ----------
st.set_page_config("PyBaMM Studio – Vertical Slice", layout="wide")
st.title("PyBaMM Studio — Vertical Slice")
st.caption(f"Python {sys.version.split()[0]} | PyBaMM { _PYBAMM_VER }")

left, right = st.columns([1,1])

with left:
    st.subheader("Experiment steps")
    st.write("One per line. Examples:")
    st.code("Charge at 0.5C until 4.2V\nRest for 5 min\nDischarge at 1C until 3.0V")
    steps_text = st.text_area("Steps", height=200, value="Charge at 0.5C until 4.2V\nRest for 5 min\nDischarge at 1C until 3.0V")
    st.subheader("Parameter overrides (key: value)")
    overlay_text = st.text_area("Overrides", height=140, value="# e.g.\nNominal cell capacity [A.h]: 2.0")
    tempC = st.number_input("Temperature [°C]", value=25.0, step=1.0)

    build = st.button("Build & Run")
    gen   = st.button("Generate Studio Script")

with right:
    if build:
        if not _PYBAMM_OK:
            st.error("PyBaMM is not available in this environment.")
        else:
            try:
                steps = parse_steps(steps_text.splitlines())
                overlay = parse_kv_block(overlay_text)
                exp, lines = to_pybamm_experiment(steps, float(tempC))
                model = pb.lithium_ion.SPM()
                params = pb.ParameterValues("Chen2020")
                if overlay:
                    params.update(overlay)
                sim = pb.Simulation(model, parameter_values=params, experiment=exp)
                sol = sim.solve()
                st.success("Run completed.")
                st.line_chart({"Voltage [V]": np.array(sol["Voltage [V]"].entries)})
                repro = {
                    "timestamp": dt.datetime.utcnow().isoformat()+"Z",
                    "pybamm_version": _PYBAMM_VER,
                    "lines": lines,
                    "overrides": overlay,
                    "tempC": float(tempC),
                }
                st.download_button("Download Repro-Pack (.json)",
                                   data=io.BytesIO(json.dumps(repro, indent=2).encode()),
                                   file_name="repro_pack.json",
                                   mime="application/json")
            except Exception as e:
                st.error(f"Run failed: {e}")

    if gen:
        try:
            steps = parse_steps(steps_text.splitlines())
            overlay = parse_kv_block(overlay_text)
            _, lines = to_pybamm_experiment(steps, float(tempC))
            script = emit_script(lines, overlay, float(tempC))
            st.subheader("Studio-ready script")
            st.code(script, language="python")
            st.download_button("Download script (pybamm_script.py)",
                               data=script.encode(),
                               file_name="pybamm_script.py",
                               mime="text/x-python")
        except Exception as e:
            st.error(f"Cannot generate script: {e}")
